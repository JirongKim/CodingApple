{"ast":null,"code":"/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar React = require('react');\n\nvar useSyncExternalStore = require('./useSyncExternalStore.js');\n\nvar index = require('../../query-core/build/esm/index.js');\n\nvar QueryErrorResetBoundary = require('./QueryErrorResetBoundary.js');\n\nvar QueryClientProvider = require('./QueryClientProvider.js');\n\nvar utils = require('./utils.js');\n\nvar isRestoring = require('./isRestoring.js');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nfunction useBaseQuery(options, Observer) {\n  const queryClient = QueryClientProvider.useQueryClient({\n    context: options.context\n  });\n  const isRestoring$1 = isRestoring.useIsRestoring();\n  const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring$1 ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = index.notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = index.notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = index.notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  const [observer] = React__namespace.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback(onStoreChange => isRestoring$1 ? () => undefined : observer.subscribe(index.notifyManager.batchCalls(onStoreChange)), [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React__namespace.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React__namespace.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring$1) {\n    throw observer.fetchOptimistic(defaultedOptions).then(_ref => {\n      let {\n        data\n      } = _ref;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(error => {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && utils.shouldThrowError(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n\nexports.useBaseQuery = useBaseQuery;","map":{"version":3,"mappings":"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","names":["useBaseQuery","options","Observer","queryClient","useQueryClient","context","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedOptions","defaultQueryOptions","_optimisticResults","onError","notifyManager","batchCalls","onSuccess","onSettled","suspense","staleTime","useErrorBoundary","isReset","retryOnMount","observer","React","useState","result","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","undefined","subscribe","getCurrentResult","useEffect","clearReset","setOptions","listeners","isLoading","isFetching","fetchOptimistic","then","data","catch","error","isError","shouldThrowError","getCurrentQuery","notifyOnChangeProps","trackResult"],"sources":["/Users/jrkim/Desktop/Programming/WEB/CodingApple/node_modules/react-query/src/useBaseQuery.ts"],"sourcesContent":["import * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { QueryKey, notifyManager, QueryObserver } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"]},"metadata":{},"sourceType":"script"}