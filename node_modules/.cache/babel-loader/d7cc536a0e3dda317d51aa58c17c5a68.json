{"ast":null,"code":"/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n} // TYPES\n// UTILS\n\n\nconst isServer = typeof window === 'undefined';\n\nfunction noop() {\n  return undefined;\n}\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\n\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\n\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\n\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\n\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\n\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\n\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\n\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\n\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\n\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\n\nfunction isError(value) {\n  return value instanceof Error;\n}\n\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\n\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\n\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\n\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\n\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\n\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\n\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\n\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay; // Stop if the fetch is already resolved\n\n\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    clearTimeout(this.gcTimeout);\n    this.gcTimeout = undefined;\n  }\n\n} // CLASS\n\n\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4; // make sure that retries that were potentially cancelled due to unmounts can continue\n\n\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config; // Notify cache callback\n\n\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n} // CLASS\n\n\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n} // CLASS\n\n\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5; // Notify cache callback\n\n\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n} // CLASS\n\n\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\n\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\n\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n} // CLASS\n\n\nclass QueryClient {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(_ref2 => {\n      let {\n        queryKey,\n        state\n      } = _ref2;\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(_ref3 => {\n      let {\n        queryKey\n      } = _ref3;\n      return [queryKey, this.setQueryData(queryKey, updater, options)];\n    }));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch() {\n    let {\n      refetchPage,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  }\n\n  clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage() {\n    let {\n      pageParam,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage() {\n    let {\n      pageParam,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n} // CLASS\n\n\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    this.options = this.client.defaultMutationOptions(options);\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n} // TYPES\n// FUNCTIONS\n\n\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\n\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexports.CancelledError = CancelledError;\nexports.InfiniteQueryObserver = InfiniteQueryObserver;\nexports.MutationCache = MutationCache;\nexports.MutationObserver = MutationObserver;\nexports.QueriesObserver = QueriesObserver;\nexports.QueryCache = QueryCache;\nexports.QueryClient = QueryClient;\nexports.QueryObserver = QueryObserver;\nexports.dehydrate = dehydrate;\nexports.focusManager = focusManager;\nexports.hashQueryKey = hashQueryKey;\nexports.hydrate = hydrate;\nexports.isCancelledError = isCancelledError;\nexports.isError = isError;\nexports.notifyManager = notifyManager;\nexports.onlineManager = onlineManager;\nexports.parseFilterArgs = parseFilterArgs;\nexports.parseMutationArgs = parseMutationArgs;\nexports.parseMutationFilterArgs = parseMutationFilterArgs;\nexports.parseQueryArgs = parseQueryArgs;","map":{"version":3,"mappings":"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","names":["Subscribable","constructor","listeners","subscribe","bind","listener","push","onSubscribe","filter","x","onUnsubscribe","hasListeners","length","isServer","window","noop","undefined","functionalUpdate","updater","input","isValidTimeout","value","Infinity","difference","array1","array2","indexOf","replaceAt","array","index","copy","slice","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","isPlainArray","aSize","bItems","bSize","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","isError","Error","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","getAbortController","AbortController","replaceData","prevData","data","isDataEqual","structuralSharing","FocusManager","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","focusManager","OnlineManager","onOnline","online","setOnline","isOnline","navigator","onLine","onlineManager","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","onSuccess","onError","pause","continueResolve","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","continue","defaultLogger","console","createNotifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","flush","schedule","batchCalls","args","originalQueue","setNotifyFunction","setBatchNotifyFunction","notifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","getDefaultState$1","meta","remove","setData","newData","dispatch","dataUpdatedAt","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","isInvalidated","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","process","env","NODE_ENV","abortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","fetchFn","context","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","_this$cache$config$on2","_this$cache$config2","action","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","dataUpdateCount","errorUpdateCount","errorUpdatedAt","onQueryUpdate","initialData","hasInitialData","initialDataUpdatedAt","hasData","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","event","Mutation","mutationId","mutationCache","getDefaultState","execute","executeMutation","_this$options$retry","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","onSettled","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onError","_this$options4","_this$options$onSettl2","_this$options5","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","_context$signal","aborted","_context$signal2","buildNewPages","param","page","previous","fetchPage","queryFnResult","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","shouldFetchNextPage","finalPromise","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isFetching","isMutating","getQueryData","_this$queryCache$find","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","parsedOptions","defaultedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","throwOnError","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","matchingDefaults","setMutationDefaults","_defaulted","refetchOnReconnect","useErrorBoundary","suspense","QueryObserver","trackedProps","Set","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","_fetchOptions$cancelR","time","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","size","includedProps","typedKey","changed","has","shouldLoadOnMount","retryOnMount","refetchOnMount","field","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","newObserversMap","fromEntries","newResult","hasIndexChange","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","sortMatchesByOrderOfQueries","concat","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","MutationObserver","mutate","_this$currentMutation","currentMutation","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","dehydrateMutation","dehydrateQuery","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","dehydrate","dehydrateMutations","shouldDehydrateMutation","dehydrateQueries","shouldDehydrateQuery","hydrate","dehydratedState","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2"],"sources":["/Users/jrkim/Desktop/Programming/WEB/CodingApple/node_modules/query-core/build/esm/index.js"],"sourcesContent":["/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    clearTimeout(this.gcTimeout);\n    this.gcTimeout = undefined;\n  }\n\n}\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  }\n\n  clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    this.options = this.client.defaultMutationOptions(options);\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { CancelledError, InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hashQueryKey, hydrate, isCancelledError, isError, notifyManager, onlineManager, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"script"}