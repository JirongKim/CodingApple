{"ast":null,"code":"/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar React = require('react');\n\nvar index = require('../../query-core/build/esm/index.js');\n\nvar QueryClientProvider = require('./QueryClientProvider.js');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nfunction useHydrate(state) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const queryClient = QueryClientProvider.useQueryClient({\n    context: options.context\n  });\n  const optionsRef = React__namespace.useRef(options);\n  optionsRef.current = options; // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n\n  React__namespace.useMemo(() => {\n    if (state) {\n      index.hydrate(queryClient, state, optionsRef.current);\n    }\n  }, [queryClient, state]);\n}\n\nconst Hydrate = _ref => {\n  let {\n    children,\n    options,\n    state\n  } = _ref;\n  useHydrate(state, options);\n  return children;\n};\n\nexports.Hydrate = Hydrate;\nexports.useHydrate = useHydrate;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMO,SAASA,UAAT,CACLC,KADK,EAGL;EAAA,IADAC,OACA,uEAD2C,EAC3C;EACA,MAAMC,WAAW,GAAGC,mCAAe;IAAEC,OAAO,EAAEH,OAAO,CAACG;EAAnB,CAAfD,CAApB;EAEA,MAAME,UAAU,GAAGC,gBAAK,CAACC,MAAND,CAAaL,OAAbK,CAAnB;EACAD,UAAU,CAACG,OAAXH,GAAqBJ,OAArBI,CAJA;EAOA;EACA;EACA;;EACAC,gBAAK,CAACG,OAANH,CAAc,MAAM;IAClB,IAAIN,KAAJ,EAAW;MACTU,cAAQR,WAARQ,EAAqBV,KAArBU,EAA4BL,UAAU,CAACG,OAAvCE;IACD;EAHH,GAIG,CAACR,WAAD,EAAcF,KAAd,CAJHM;AAKD;;AAQM,MAAMK,OAAO,GAAG,QAAgD;EAAA,IAA/C;IAAEC,QAAF;IAAYX,OAAZ;IAAqBD;EAArB,CAA+C;EACrED,UAAU,CAACC,KAAD,EAAQC,OAAR,CAAVF;EACA,OAAOa,QAAP;AACD,CAHM","names":["useHydrate","state","options","queryClient","useQueryClient","context","optionsRef","React","useRef","current","useMemo","hydrate","Hydrate","children"],"sources":["/Users/jrkim/Desktop/Programming/WEB/CodingApple/node_modules/react-query/src/Hydrate.tsx"],"sourcesContent":["import * as React from 'react'\n\nimport { hydrate, HydrateOptions } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n"]},"metadata":{},"sourceType":"script"}